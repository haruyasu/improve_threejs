<!DOCTYPE html>
<html lang="en">
    <head>
        <title>Game Settings</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
        <style>
            body {
                margin: 0px;
                overflow: hidden;
            }

            .game-holder {
                position: absolute;
                width: 100%;
                height: 100%;
                background: -webkit-linear-gradient(#247BA0, #70C1B3);
                background: linear-gradient(#247BA0, #70C1B3);
            }

            .world {
                position: absolute;
                overflow: hidden;
                width: 100%;
                height: 100%;
            }

            .header {
                position: absolute;
                top: 8vh;
                left: 0;
                width: 100%;
                text-align: center;
                pointer-events: none;
            }

            .header h1 {
                font-family: "Playfair Display";
                font-size: 4.5em;
                line-height: 1;
                margin: 0;
                letter-spacing: -0.025em;
                color: #d1b790;
            }

            .header h1 span {
                font-size: 0.2em;
                font-style: italic;
                display: block;
                margin: 0 0 -1.5em -7em;
                letter-spacing: 0px;
            }

            .header h2 {
                font-size: 0.585em;
                margin: 0.25em 0;
                white-space: nowrap;
                text-indent: 1em;
                letter-spacing: 1em;
                text-transform: uppercase;
                color: #d6483b;
            }

            .score {
                width: 100%;
                margin: 2em 0 0;
                text-align: center;
                white-space: nowrap;
            }

            .score__content {
                position: relative;
                display: inline-block;
                padding: 0 1em;
                vertical-align: top;
            }

            .score__content:nth-child(2) {
                border-right: 1px solid #d1b790;
                border-left: 1px solid #d1b790;
            }

            .score__label {
                font-size: 9px;
                position: relative;
                margin: 0 0 0.5em 0;
                text-align: center;
                letter-spacing: 3px;
                text-transform: uppercase;
                color: #d1b790;
            }

            .score__value {
                font-family: "Playfair Display";
                font-weight: bold;
                color: #d1b790;
            }

            .score__value--level {
                font-size: 26px;
            }

            .score__value--dist {
                font-size: 30px;
            }

            .level-circle {
                position: absolute;
                left: 50%;
                width: 46px;
                margin: -37px 0 0 -23px;
                -webkit-transform: rotate(-90deg);
                transform: rotate(-90deg);
            }

            .score__value--energy {
                position: relative;
                width: 60px;
                height: 8px;
                margin-top: 20px;
                border-radius: 3px;
                background-color: #d1b790;
            }

            .energy-bar {
                position: absolute;
                top: 0;
                right: 0;
                bottom: 0;
                left: 0;
                margin: 2px;
                background-color: #f25346;
                -webkit-animation-name: none;
                animation-name: none;
                -webkit-animation-duration: 150ms;
                animation-duration: 150ms;
                -webkit-animation-iteration-count: infinite;
                animation-iteration-count: infinite;
            }

            .message {
                font-weight: bold;
                position: absolute;
                left: 0;
                width: 100%;
                text-align: center;
                text-transform: uppercase;
                pointer-events: none;
            }

            .message--replay {
                font-size: 1.25vw;
                bottom: 40vh;
                display: none;
                text-indent: 0.5em;
                letter-spacing: 0.5em;
                color: #d1b790;
            }

            @-webkit-keyframes blinking {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @keyframes blinking {
                0% {
                    opacity: 1;
                }
                50% {
                    opacity: 0;
                }
                100% {
                    opacity: 1;
                }
            }

            @media screen and (max-width: 40em) {
                .header {
                    font-size: 0.75em;
                    top: 6.5em;
                }
                .header h2 {
                    letter-spacing: 0.65em;
                }
            }
        </style>
    </head>
    <body>
        <div class="game-holder" id="gameHolder">
            <div class="header">
                <div class="score" id="score">
                    <div class="score__content" id="level">
                        <div class="score__label">level</div>
                        <div class="score__value score__value--level" id="levelValue">1</div>
                        <svg class="level-circle" id="levelCircle" viewbox="0 0 200 200">
                            <circle
                                id="levelCircleBgr"
                                r="80"
                                cx="100"
                                cy="100"
                                fill="none"
                                stroke="#d1b790"
                                stroke-width="24px"
                            />
                            <circle
                                id="levelCircleStroke"
                                r="80"
                                cx="100"
                                cy="100"
                                fill="none"
                                #f25346
                                stroke="#68c3c0"
                                stroke-width="14px"
                                stroke-dasharray="502"
                            />
                        </svg>
                    </div>
                    <div class="score__content" id="dist">
                        <div class="score__label">distance</div>
                        <div class="score__value score__value--dist" id="distValue">000</div>
                    </div>
                    <div class="score__content" id="energy">
                        <div class="score__label">energy</div>
                        <div class="score__value score__value--energy" id="energyValue">
                            <div class="energy-bar" id="energyBar"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="world" id="world"></div>
            <div class="message message--replay" id="replayMessage">Click to Replay</div>
        </div>

        <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r98/build/three.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/latest/TweenMax.min.js"></script>

        <script>
            //COLORS
            var Colors = {
                red: 0xf25346,
                white: 0xd8d0d1,
                brown: 0x59332e,
                brownDark: 0x23190f,
                pink: 0xf5986e,
                yellow: 0xf4ce93,
                blue: 0x68c3c0
            };

            // GAME VARIABLES
            var game;
            var deltaTime = 0;
            var newTime = new Date().getTime();
            var oldTime = new Date().getTime();
            var ennemiesPool = [];
            var particlesPool = [];
            var particlesInUse = [];

            function resetGame() {
                game = {
                    speed: 0,
                    initSpeed: 0.00035,
                    baseSpeed: 0.00035,
                    targetBaseSpeed: 0.00035,
                    incrementSpeedByTime: 0.0000025,
                    incrementSpeedByLevel: 0.000005,
                    distanceForSpeedUpdate: 100,
                    speedLastUpdate: 0,

                    distance: 0,
                    ratioSpeedDistance: 50,
                    energy: 100,
                    ratioSpeedEnergy: 3,

                    level: 1,
                    levelLastUpdate: 0,
                    distanceForLevelUpdate: 1000,

                    planeDefaultHeight: 100,
                    planeAmpHeight: 80,
                    planeAmpWidth: 75,
                    planeMoveSensivity: 0.005,
                    planeRotXSensivity: 0.0008,
                    planeRotZSensivity: 0.0004,
                    planeFallSpeed: 0.001,
                    planeMinSpeed: 1.2,
                    planeMaxSpeed: 1.6,
                    planeSpeed: 0,
                    planeCollisionDisplacementX: 0,
                    planeCollisionSpeedX: 0,

                    planeCollisionDisplacementY: 0,
                    planeCollisionSpeedY: 0,

                    seaRadius: 600,
                    seaLength: 800,
                    //seaRotationSpeed:0.006,
                    wavesMinAmp: 5,
                    wavesMaxAmp: 20,
                    wavesMinSpeed: 0.001,
                    wavesMaxSpeed: 0.003,

                    cameraFarPos: 500,
                    cameraNearPos: 150,
                    cameraSensivity: 0.002,

                    coinDistanceTolerance: 15,
                    coinValue: 3,
                    coinsSpeed: 0.5,
                    coinLastSpawn: 0,
                    distanceForCoinsSpawn: 100,

                    ennemyDistanceTolerance: 10,
                    ennemyValue: 10,
                    ennemiesSpeed: 0.6,
                    ennemyLastSpawn: 0,
                    distanceForEnnemiesSpawn: 50,

                    status: "playing"
                };
                fieldLevel.innerHTML = Math.floor(game.level);
            }

            //THREEJS RELATED VARIABLES

            var scene, camera, fieldOfView, aspectRatio, nearPlane, farPlane, renderer, container, controls;

            //SCREEN & MOUSE VARIABLES

            var HEIGHT,
                WIDTH,
                mousePos = { x: 0, y: 0 };

            //INIT THREE JS, SCREEN AND MOUSE EVENTS

            function createScene() {
                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;

                scene = new THREE.Scene();
                aspectRatio = WIDTH / HEIGHT;
                fieldOfView = 50;
                nearPlane = 0.1;
                farPlane = 10000;
                camera = new THREE.PerspectiveCamera(fieldOfView, aspectRatio, nearPlane, farPlane);
                scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);
                camera.position.x = 0;
                camera.position.z = 200;
                camera.position.y = game.planeDefaultHeight;
                //camera.lookAt(new THREE.Vector3(0, 400, 0));

                renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                renderer.setSize(WIDTH, HEIGHT);

                renderer.shadowMap.enabled = true;

                container = document.getElementById("world");
                container.appendChild(renderer.domElement);

                window.addEventListener("resize", handleWindowResize, false);

            }

            // MOUSE AND SCREEN EVENTS

            function handleWindowResize() {
                HEIGHT = window.innerHeight;
                WIDTH = window.innerWidth;
                renderer.setSize(WIDTH, HEIGHT);
                camera.aspect = WIDTH / HEIGHT;
                camera.updateProjectionMatrix();
            }

            function handleMouseMove(event) {
                var tx = -1 + (event.clientX / WIDTH) * 2;
                var ty = 1 - (event.clientY / HEIGHT) * 2;
                mousePos = { x: tx, y: ty };
            }

            function handleTouchMove(event) {
                event.preventDefault();
                var tx = -1 + (event.touches[0].pageX / WIDTH) * 2;
                var ty = 1 - (event.touches[0].pageY / HEIGHT) * 2;
                mousePos = { x: tx, y: ty };
            }

            function handleMouseUp(event) {
                if (game.status == "waitingReplay") {
                    resetGame();
                    hideReplay();
                }
            }

            function handleTouchEnd(event) {
                if (game.status == "waitingReplay") {
                    resetGame();
                    hideReplay();
                }
            }

            // LIGHTS

            var ambientLight, hemisphereLight, shadowLight;

            function createLights() {
                hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, 0.9);
                ambientLight = new THREE.AmbientLight(0xdc8874, 0.5);
                shadowLight = new THREE.DirectionalLight(0xffffff, 0.9);
                shadowLight.position.set(150, 350, 350);
                shadowLight.castShadow = true;
                shadowLight.shadow.camera.left = -400;
                shadowLight.shadow.camera.right = 400;
                shadowLight.shadow.camera.top = 400;
                shadowLight.shadow.camera.bottom = -400;
                shadowLight.shadow.camera.near = 1;
                shadowLight.shadow.camera.far = 1000;
                shadowLight.shadow.mapSize.width = 2048;
                shadowLight.shadow.mapSize.height = 2048;
                scene.add(hemisphereLight);
                scene.add(shadowLight);
                scene.add(ambientLight);
            }

            var AirPlane = function() {
                this.mesh = new THREE.Object3D();
                this.mesh.name = "airPlane";

                // Cockpit
                var geomCockpit = new THREE.BoxGeometry(60, 30, 40, 1, 1, 1);
                var matCockpit = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
                cockpit.castShadow = true;
                cockpit.receiveShadow = true;
                this.mesh.add(cockpit);

                var geomCockpit_2 = new THREE.BoxGeometry(20, 15, 40, 1, 1, 1);
                var matCockpit_2 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_2 = new THREE.Mesh(geomCockpit_2, matCockpit_2);
                geomCockpit_2.vertices[0].y -= 12;
                geomCockpit_2.vertices[1].y -= 12;
                cockpit_2.position.y = 22;
                cockpit_2.position.x = 20;
                cockpit_2.castShadow = true;
                cockpit_2.receiveShadow = true;
                this.mesh.add(cockpit_2);

                var geomCockpit_3 = new THREE.BoxGeometry(30, 15, 40, 1, 1, 1);
                var matCockpit_3 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_3 = new THREE.Mesh(geomCockpit_3, matCockpit_3);
                cockpit_3.position.y = 22;
                cockpit_3.position.x = -5;
                cockpit_3.castShadow = true;
                cockpit_3.receiveShadow = true;
                this.mesh.add(cockpit_3);
                // propeller plate
                var geomCockpit_4 = new THREE.BoxGeometry(20, 5, 30, 1, 1, 1);
                var matCockpit_4 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_4 = new THREE.Mesh(geomCockpit_4, matCockpit_4);
                cockpit_4.position.y = 32;
                cockpit_4.position.x = -5;
                cockpit_4.castShadow = true;
                cockpit_4.receiveShadow = true;
                this.mesh.add(cockpit_4);
                // Tail before
                var geomCockpit_5 = new THREE.BoxGeometry(30, 30, 25, 1, 1, 1);
                var matCockpit_5 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_5 = new THREE.Mesh(geomCockpit_5, matCockpit_5);
                geomCockpit_5.vertices[6].y += 3;
                geomCockpit_5.vertices[6].z += 3;
                geomCockpit_5.vertices[4].z += 3;
                geomCockpit_5.vertices[7].y += 3;
                geomCockpit_5.vertices[7].z -= 3;
                geomCockpit_5.vertices[5].z -= 3;
                cockpit_5.position.y = 5;
                cockpit_5.position.x = -35;
                cockpit_5.castShadow = true;
                cockpit_5.receiveShadow = true;
                this.mesh.add(cockpit_5);
                // Tail
                var geomCockpit_6 = new THREE.BoxGeometry(80, 15, 15, 1, 1, 1);
                var matCockpit_6 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_6 = new THREE.Mesh(geomCockpit_6, matCockpit_6);
                geomCockpit_6.vertices[6].y += 10;
                geomCockpit_6.vertices[6].z += 6;
                geomCockpit_6.vertices[4].z += 6;
                geomCockpit_6.vertices[7].y += 10;
                geomCockpit_6.vertices[7].z -= 6;
                geomCockpit_6.vertices[5].z -= 6;
                cockpit_6.position.y = 10;
                cockpit_6.position.x = -90;
                cockpit_6.castShadow = true;
                cockpit_6.receiveShadow = true;
                this.mesh.add(cockpit_6);
                // Tail before up
                var geomCockpit_7 = new THREE.BoxGeometry(20, 7, 15, 1, 1, 1);
                var matCockpit_7 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_7 = new THREE.Mesh(geomCockpit_7, matCockpit_7);
                geomCockpit_7.vertices[5].y -= 2;
                geomCockpit_7.vertices[4].y -= 2;
                cockpit_7.position.y = 23;
                cockpit_7.position.x = -30;
                cockpit_7.castShadow = true;
                cockpit_7.receiveShadow = true;
                this.mesh.add(cockpit_7);

                var geomCockpit_8 = new THREE.BoxGeometry(10, 20, 1, 1, 1, 1);
                var matCockpit_8 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_8 = new THREE.Mesh(geomCockpit_8, matCockpit_8);
                geomCockpit_8.vertices[0].x -= 8;
                geomCockpit_8.vertices[1].x -= 8;
                cockpit_8.position.y = 25;
                cockpit_8.position.x = -126.8;
                cockpit_8.rotation.z = Math.PI / 12;

                cockpit_8.castShadow = true;
                cockpit_8.receiveShadow = true;
                this.mesh.add(cockpit_8);

                var geomCockpit_9 = new THREE.BoxGeometry(10, 15, 1, 1, 1, 1);
                var matCockpit_9 = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
                var cockpit_9 = new THREE.Mesh(geomCockpit_9, matCockpit_9);
                geomCockpit_9.vertices[2].x -= 8;
                geomCockpit_9.vertices[3].x -= 8;
                cockpit_9.position.y = 5.5;
                cockpit_9.position.x = -126.8;
                cockpit_9.rotation.z = -Math.PI / 12;
                cockpit_9.castShadow = true;
                cockpit_9.receiveShadow = true;
                this.mesh.add(cockpit_9);

                // Engine
                var geomEngine = new THREE.BoxGeometry(30, 20, 42, 1, 1, 1);
                // var matEngine = new THREE.MeshPhongMaterial({ color: Colors.white, shading: THREE.FlatShading });

                var matEngine = new THREE.MeshPhongMaterial({
                    color: Colors.blue,
                    transparent: true,
                    opacity: 0.5,
                    shading: THREE.FlatShading
                });

                var engine = new THREE.Mesh(geomEngine, matEngine);
                engine.position.x = 16;
                engine.position.y = 4;
                engine.position.z = 0;
                engine.castShadow = true;
                engine.receiveShadow = true;
                this.mesh.add(engine);

                // wheel bar
                var geomBar= new THREE.BoxGeometry(60, 2, 3, 1, 1, 1);
                var matBar = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
                var barL = new THREE.Mesh(geomBar, matBar);
                barL.position.y = -22;
                barL.position.z = -20;
                barL.castShadow = true;
                barL.receiveShadow = true;
                this.mesh.add(barL);
                var barR = barL.clone();
                barR.position.z = -barL.position.z;
                this.mesh.add(barR);

                // legs
                var geomleg= new THREE.BoxGeometry(3, 9, 1, 1, 1, 1);
                var matLeg = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
                var legLF = new THREE.Mesh(geomleg, matLeg);
                legLF.position.x = 17;
                legLF.position.y = -17;
                legLF.position.z = -19;
                legLF.rotation.x = Math.PI / 12;
                legLF.castShadow = true;
                legLF.receiveShadow = true;
                this.mesh.add(legLF);
                var legLB = legLF.clone();
                legLB.position.x = -legLF.position.x;
                this.mesh.add(legLB);
                var legRF = legLF.clone();
                legRF.position.z = -legLF.position.z;
                legRF.rotation.x = -legLF.rotation.x
                this.mesh.add(legRF);
                var legRB = legRF.clone();
                legRB.position.x = -legLF.position.x;
                this.mesh.add(legRB);
                // Propller
                var geomPropeller = new THREE.BoxGeometry(20, 5, 5, 1, 1, 1);
                geomPropeller.vertices[4].y -= 2;
                geomPropeller.vertices[4].z += 2;
                geomPropeller.vertices[5].y -= 2;
                geomPropeller.vertices[5].z -= 2;
                geomPropeller.vertices[6].y += 2;
                geomPropeller.vertices[6].z += 2;
                geomPropeller.vertices[7].y += 2;
                geomPropeller.vertices[7].z -= 2;
                var matPropeller = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
                this.propeller = new THREE.Mesh(geomPropeller, matPropeller);
                this.propeller.rotation.z = Math.PI / 2;
                this.propeller.castShadow = true;
                this.propeller.receiveShadow = true;

                var geomBlade = new THREE.BoxGeometry(1, 140, 8, 1, 1, 1);
                var matBlade = new THREE.MeshPhongMaterial({ color: Colors.brownDark, shading: THREE.FlatShading });
                var blade1 = new THREE.Mesh(geomBlade, matBlade);
                blade1.position.set(8, 0, 0);
                blade1.castShadow = true;
                blade1.receiveShadow = true;
                var blade2 = blade1.clone();
                blade2.rotation.x = Math.PI / 2;
                blade2.castShadow = true;
                blade2.receiveShadow = true;
                this.propeller.add(blade1);
                this.propeller.add(blade2);
                this.propeller.position.set(-5, 35, 0);
                this.mesh.add(this.propeller);

                // Propeller tail
                var geomPropeller_tail = new THREE.BoxGeometry(5, 2, 2, 1, 1, 1);
                geomPropeller_tail.vertices[4].y -= 1;
                geomPropeller_tail.vertices[4].z += 1;
                geomPropeller_tail.vertices[5].y -= 1;
                geomPropeller_tail.vertices[5].z -= 1;
                geomPropeller_tail.vertices[6].y += 1;
                geomPropeller_tail.vertices[6].z += 1;
                geomPropeller_tail.vertices[7].y += 1;
                geomPropeller_tail.vertices[7].z -= 1;
                var matPropeller_tail = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
                this.propeller_tail = new THREE.Mesh(geomPropeller_tail, matPropeller_tail);
                this.propeller_tail.rotation.z = Math.PI / 2;
                this.propeller_tail.rotation.x = -Math.PI / 2;
                this.propeller_tail.castShadow = true;
                this.propeller_tail.receiveShadow = true;

                var geomBlade_tail = new THREE.BoxGeometry(1, 30, 2, 1, 1, 1);
                var matBlade_tail = new THREE.MeshPhongMaterial({ color: Colors.brownDark, shading: THREE.FlatShading });
                var blade1_tail = new THREE.Mesh(geomBlade_tail, matBlade_tail);
                blade1_tail.position.set(1.5, 0, 0);
                blade1_tail.castShadow = true;
                blade1_tail.receiveShadow = true;
                var blade2_tail = blade1_tail.clone();
                blade2_tail.rotation.x = Math.PI / 2;
                blade2_tail.castShadow = true;
                blade2_tail.receiveShadow = true;
                this.propeller_tail.add(blade1_tail);
                this.propeller_tail.add(blade2_tail);
                this.propeller_tail.position.set(-125, 15, -3);
                this.mesh.add(this.propeller_tail);


                this.mesh.castShadow = true;
                this.mesh.receiveShadow = true;

            };

            AirPlane.prototype.run = function() {
                airplane.propeller.rotation.y += 0.3;
                airplane.propeller_tail.rotation.y += 0.3;
            };

            Sea = function() {
                var geom = new THREE.SphereGeometry(600, 60, 60);
                geom.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                geom.mergeVertices();
                var l = geom.vertices.length;
                this.waves = [];
                for (var i = 0; i < l; i++) {
                    var v = geom.vertices[i];
                    this.waves.push({
                        y: v.y,
                        x: v.x,
                        z: v.z,
                        ang: Math.random() * Math.PI * 2,
                        amp: 5 + Math.random() * 2,
                        speed: 0.016 + Math.random() * 0.032
                    });
                }
                var mat = new THREE.MeshPhongMaterial({
                    color: Colors.brown,
                    transparent: true,
                    opacity: 0.9,
                    shading: THREE.FlatShading
                });

                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.receiveShadow = true;
            };

            Sea.prototype.moveWaves = function() {
                var verts = this.mesh.geometry.vertices;
                var l = verts.length;
                for (var i = 0; i < l; i++) {
                    var v = verts[i];
                    var vprops = this.waves[i];
                    v.x = vprops.x + Math.cos(vprops.ang) * vprops.amp;
                    v.y = vprops.y + Math.sin(vprops.ang) * vprops.amp;
                    vprops.ang += vprops.speed;
                }
                this.mesh.geometry.verticesNeedUpdate = true;
                sea.mesh.rotation.z += 0.002;
            };

            Ennemy = function() {
                var geom = new THREE.TetrahedronGeometry(8, 2);
                var mat = new THREE.MeshPhongMaterial({
                    color: Colors.red,
                    shininess: 0,
                    specular: 0xffffff,
                    shading: THREE.FlatShading
                });
                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.castShadow = true;
                this.angle = 0;
                this.dist = 0;
            };

            EnnemiesHolder = function() {
                this.mesh = new THREE.Object3D();
                this.ennemiesInUse = [];
            };

            EnnemiesHolder.prototype.spawnEnnemies = function() {
                var nEnnemies = game.level;

                for (var i = 0; i < nEnnemies; i++) {
                    var ennemy;
                    if (ennemiesPool.length) {
                        ennemy = ennemiesPool.pop();
                    } else {
                        ennemy = new Ennemy();
                    }

                    ennemy.angle = -(i * 0.1);
                    ennemy.distance =
                        game.seaRadius +
                        game.planeDefaultHeight +
                        (-1 + Math.random() * 2) * (game.planeAmpHeight - 20);
                    ennemy.mesh.position.y = -game.seaRadius + Math.sin(ennemy.angle) * ennemy.distance;
                    ennemy.mesh.position.x = Math.cos(ennemy.angle) * ennemy.distance;

                    this.mesh.add(ennemy.mesh);
                    this.ennemiesInUse.push(ennemy);
                }
            };

            EnnemiesHolder.prototype.rotateEnnemies = function() {
                for (var i = 0; i < this.ennemiesInUse.length; i++) {
                    var ennemy = this.ennemiesInUse[i];
                    ennemy.angle += game.speed * deltaTime * game.ennemiesSpeed;

                    if (ennemy.angle > Math.PI * 2) ennemy.angle -= Math.PI * 2;

                    ennemy.mesh.position.y = -game.seaRadius + Math.sin(ennemy.angle) * ennemy.distance;
                    ennemy.mesh.position.x = Math.cos(ennemy.angle) * ennemy.distance;
                    ennemy.mesh.rotation.z += Math.random() * 0.1;
                    ennemy.mesh.rotation.y += Math.random() * 0.1;

                    var diffPos = airplane.mesh.position.clone().sub(ennemy.mesh.position.clone());
                    var d = diffPos.length();
                    if (d < game.ennemyDistanceTolerance) {
                        particlesHolder.spawnParticles(ennemy.mesh.position.clone(), 15, Colors.red, 3);

                        ennemiesPool.unshift(this.ennemiesInUse.splice(i, 1)[0]);
                        this.mesh.remove(ennemy.mesh);
                        game.planeCollisionSpeedX = (100 * diffPos.x) / d;
                        game.planeCollisionSpeedY = (100 * diffPos.y) / d;
                        ambientLight.intensity = 2;

                        removeEnergy();
                        i--;
                    } else if (ennemy.angle > Math.PI) {
                        ennemiesPool.unshift(this.ennemiesInUse.splice(i, 1)[0]);
                        this.mesh.remove(ennemy.mesh);
                        i--;
                    }
                }
            };

            Particle = function() {
                var geom = new THREE.TetrahedronGeometry(3, 0);
                var mat = new THREE.MeshPhongMaterial({
                    color: 0x009999,
                    shininess: 0,
                    specular: 0xffffff,
                    shading: THREE.FlatShading
                });
                this.mesh = new THREE.Mesh(geom, mat);
            };

            Particle.prototype.explode = function(pos, color, scale) {
                var _this = this;
                var _p = this.mesh.parent;
                this.mesh.material.color = new THREE.Color(color);
                this.mesh.material.needsUpdate = true;
                this.mesh.scale.set(scale, scale, scale);
                var targetX = pos.x + (-1 + Math.random() * 2) * 50;
                var targetY = pos.y + (-1 + Math.random() * 2) * 50;
                var speed = 0.6 + Math.random() * 0.2;
                TweenMax.to(this.mesh.rotation, speed, { x: Math.random() * 12, y: Math.random() * 12 });
                TweenMax.to(this.mesh.scale, speed, { x: 0.1, y: 0.1, z: 0.1 });
                TweenMax.to(this.mesh.position, speed, {
                    x: targetX,
                    y: targetY,
                    delay: Math.random() * 0.1,
                    ease: Power2.easeOut,
                    onComplete: function() {
                        if (_p) _p.remove(_this.mesh);
                        _this.mesh.scale.set(1, 1, 1);
                        particlesPool.unshift(_this);
                    }
                });
            };

            ParticlesHolder = function() {
                this.mesh = new THREE.Object3D();
                this.particlesInUse = [];
            };

            ParticlesHolder.prototype.spawnParticles = function(pos, density, color, scale) {
                var nPArticles = density;
                for (var i = 0; i < nPArticles; i++) {
                    var particle;
                    if (particlesPool.length) {
                        particle = particlesPool.pop();
                    } else {
                        particle = new Particle();
                    }
                    this.mesh.add(particle.mesh);
                    particle.mesh.visible = true;
                    var _this = this;
                    particle.mesh.position.y = pos.y;
                    particle.mesh.position.x = pos.x;
                    particle.explode(pos, color, scale);
                }
            };

            Coin = function() {
                var geom = new THREE.TetrahedronGeometry(5, 0);
                var mat = new THREE.MeshPhongMaterial({
                    color: 0x009999,
                    shininess: 0,
                    specular: 0xffffff,
                    shading: THREE.FlatShading
                });
                this.mesh = new THREE.Mesh(geom, mat);
                this.mesh.castShadow = true;
                this.angle = 0;
                this.dist = 0;
            };

            CoinsHolder = function(nCoins) {
                this.mesh = new THREE.Object3D();
                this.coinsInUse = [];
                this.coinsPool = [];
                for (var i = 0; i < nCoins; i++) {
                    var coin = new Coin();
                    this.coinsPool.push(coin);
                }
            };

            CoinsHolder.prototype.spawnCoins = function() {
                var nCoins = 1 + Math.floor(Math.random() * 10);
                var d =
                    game.seaRadius + game.planeDefaultHeight + (-1 + Math.random() * 2) * (game.planeAmpHeight - 20);
                var amplitude = 10 + Math.round(Math.random() * 10);
                for (var i = 0; i < nCoins; i++) {
                    var coin;
                    if (this.coinsPool.length) {
                        coin = this.coinsPool.pop();
                    } else {
                        coin = new Coin();
                    }
                    this.mesh.add(coin.mesh);
                    this.coinsInUse.push(coin);
                    coin.angle = -(i * 0.02);
                    coin.distance = d + Math.cos(i * 0.5) * amplitude;
                    coin.mesh.position.y = -game.seaRadius + Math.sin(coin.angle) * coin.distance;
                    coin.mesh.position.x = Math.cos(coin.angle) * coin.distance;
                }
            };

            CoinsHolder.prototype.rotateCoins = function() {
                for (var i = 0; i < this.coinsInUse.length; i++) {
                    var coin = this.coinsInUse[i];
                    if (coin.exploding) continue;
                    coin.angle += game.speed * deltaTime * game.coinsSpeed;
                    if (coin.angle > Math.PI * 2) coin.angle -= Math.PI * 2;
                    coin.mesh.position.y = -game.seaRadius + Math.sin(coin.angle) * coin.distance;
                    coin.mesh.position.x = Math.cos(coin.angle) * coin.distance;
                    coin.mesh.rotation.z += Math.random() * 0.1;
                    coin.mesh.rotation.y += Math.random() * 0.1;

                    var diffPos = airplane.mesh.position.clone().sub(coin.mesh.position.clone());
                    var d = diffPos.length();
                    if (d < game.coinDistanceTolerance) {
                        this.coinsPool.unshift(this.coinsInUse.splice(i, 1)[0]);
                        this.mesh.remove(coin.mesh);
                        particlesHolder.spawnParticles(coin.mesh.position.clone(), 5, 0x009999, 0.8);
                        addEnergy();
                        i--;
                    } else if (coin.angle > Math.PI) {
                        this.coinsPool.unshift(this.coinsInUse.splice(i, 1)[0]);
                        this.mesh.remove(coin.mesh);
                        i--;
                    }
                }
            };

            // 3D Models
            var airplane;

            function createPlane() {
                airplane = new AirPlane();
                p_scale = 0.3;
                airplane.mesh.scale.set(p_scale, p_scale, p_scale);
                scene.add(airplane.mesh);
            }

            function createSea() {
                sea = new Sea();
                sea.mesh.position.y = -600;
                sea.mesh.position.z = -200;
                scene.add(sea.mesh);
            }

            function createCoins() {
                coinsHolder = new CoinsHolder(20);
                scene.add(coinsHolder.mesh);
            }

            function createEnnemies() {
                for (var i = 0; i < 10; i++) {
                    var ennemy = new Ennemy();
                    ennemiesPool.push(ennemy);
                }
                ennemiesHolder = new EnnemiesHolder();
                scene.add(ennemiesHolder.mesh);
            }

            function createParticles() {
                for (var i = 0; i < 10; i++) {
                    var particle = new Particle();
                    particlesPool.push(particle);
                }
                particlesHolder = new ParticlesHolder();
                scene.add(particlesHolder.mesh);
            }

            function loop() {
                newTime = new Date().getTime();
                deltaTime = newTime - oldTime;
                oldTime = newTime;

                if (game.status == "playing") {
                    // Add energy coins every 100m;
                    if (
                        Math.floor(game.distance) % game.distanceForCoinsSpawn == 0 &&
                        Math.floor(game.distance) > game.coinLastSpawn
                    ) {
                        game.coinLastSpawn = Math.floor(game.distance);
                        coinsHolder.spawnCoins();
                    }

                    if (
                        Math.floor(game.distance) % game.distanceForSpeedUpdate == 0 &&
                        Math.floor(game.distance) > game.speedLastUpdate
                    ) {
                        game.speedLastUpdate = Math.floor(game.distance);
                        game.targetBaseSpeed += game.incrementSpeedByTime * deltaTime;
                    }

                    if (
                        Math.floor(game.distance) % game.distanceForEnnemiesSpawn == 0 &&
                        Math.floor(game.distance) > game.ennemyLastSpawn
                    ) {
                        game.ennemyLastSpawn = Math.floor(game.distance);
                        ennemiesHolder.spawnEnnemies();
                    }

                    if (
                        Math.floor(game.distance) % game.distanceForLevelUpdate == 0 &&
                        Math.floor(game.distance) > game.levelLastUpdate
                    ) {
                        game.levelLastUpdate = Math.floor(game.distance);
                        game.level++;
                        fieldLevel.innerHTML = Math.floor(game.level);

                        game.targetBaseSpeed = game.initSpeed + game.incrementSpeedByLevel * game.level;
                    }

                    updatePlane();
                    updateDistance();
                    updateEnergy();
                    game.baseSpeed += (game.targetBaseSpeed - game.baseSpeed) * deltaTime * 0.02;
                    game.speed = game.baseSpeed * game.planeSpeed;
                } else if (game.status == "gameover") {
                    game.speed *= 0.99;
                    airplane.mesh.rotation.z += (-Math.PI / 2 - airplane.mesh.rotation.z) * 0.0002 * deltaTime;
                    airplane.mesh.rotation.x += 0.0003 * deltaTime;
                    game.planeFallSpeed *= 1.05;
                    airplane.mesh.position.y -= game.planeFallSpeed * deltaTime;

                    if (airplane.mesh.position.y < -200) {
                        showReplay();
                        game.status = "waitingReplay";
                    }
                } else if (game.status == "waitingReplay") {
                }

                airplane.run();
                sea.moveWaves();

                ambientLight.intensity += (0.5 - ambientLight.intensity) * deltaTime * 0.005;

                coinsHolder.rotateCoins();
                ennemiesHolder.rotateEnnemies();

                renderer.render(scene, camera);
                requestAnimationFrame(loop);
            }

            function updateDistance() {
                game.distance += game.speed * deltaTime * game.ratioSpeedDistance;
                fieldDistance.innerHTML = Math.floor(game.distance);
                var d = 502 * (1 - (game.distance % game.distanceForLevelUpdate) / game.distanceForLevelUpdate);
                levelCircle.setAttribute("stroke-dashoffset", d);
            }

            var blinkEnergy = false;

            function updateEnergy() {
                game.energy -= game.speed * deltaTime * game.ratioSpeedEnergy;
                game.energy = Math.max(0, game.energy);
                energyBar.style.right = 100 - game.energy + "%";
                energyBar.style.backgroundColor = game.energy < 50 ? "#f25346" : "#68c3c0";

                if (game.energy < 30) {
                    energyBar.style.animationName = "blinking";
                } else {
                    energyBar.style.animationName = "none";
                }

                if (game.energy < 1) {
                    game.status = "gameover";
                }
            }

            function addEnergy() {
                game.energy += game.coinValue;
                game.energy = Math.min(game.energy, 100);
            }

            function removeEnergy() {
                game.energy -= game.ennemyValue;
                game.energy = Math.max(0, game.energy);
            }

            function updatePlane() {
                game.planeSpeed = normalize(mousePos.x, -0.5, 0.5, game.planeMinSpeed, game.planeMaxSpeed);
                var targetY = normalize(
                    mousePos.y,
                    -0.75,
                    0.75,
                    game.planeDefaultHeight - game.planeAmpHeight,
                    game.planeDefaultHeight + game.planeAmpHeight
                );
                var targetX = normalize(mousePos.x, -1, 1, -game.planeAmpWidth * 0.7, -game.planeAmpWidth);

                game.planeCollisionDisplacementX += game.planeCollisionSpeedX;
                targetX += game.planeCollisionDisplacementX;

                game.planeCollisionDisplacementY += game.planeCollisionSpeedY;
                targetY += game.planeCollisionDisplacementY;

                airplane.mesh.position.y += (targetY - airplane.mesh.position.y) * deltaTime * game.planeMoveSensivity;
                airplane.mesh.position.x += (targetX - airplane.mesh.position.x) * deltaTime * game.planeMoveSensivity;

                airplane.mesh.rotation.z = (targetY - airplane.mesh.position.y) * deltaTime * game.planeRotXSensivity;
                airplane.mesh.rotation.x = (airplane.mesh.position.y - targetY) * deltaTime * game.planeRotZSensivity;
                var targetCameraZ = normalize(
                    game.planeSpeed,
                    game.planeMinSpeed,
                    game.planeMaxSpeed,
                    game.cameraNearPos,
                    game.cameraFarPos
                );
                camera.fov = normalize(mousePos.x, -1, 1, 40, 80);
                camera.updateProjectionMatrix();
                camera.position.y += (airplane.mesh.position.y - camera.position.y) * deltaTime * game.cameraSensivity;

                game.planeCollisionSpeedX += (0 - game.planeCollisionSpeedX) * deltaTime * 0.03;
                game.planeCollisionDisplacementX += (0 - game.planeCollisionDisplacementX) * deltaTime * 0.01;
                game.planeCollisionSpeedY += (0 - game.planeCollisionSpeedY) * deltaTime * 0.03;
                game.planeCollisionDisplacementY += (0 - game.planeCollisionDisplacementY) * deltaTime * 0.01;

            }

            function showReplay() {
                replayMessage.style.display = "block";
            }

            function hideReplay() {
                replayMessage.style.display = "none";
            }

            function normalize(v, vmin, vmax, tmin, tmax) {
                var nv = Math.max(Math.min(v, vmax), vmin);
                var dv = vmax - vmin;
                var pc = (nv - vmin) / dv;
                var dt = tmax - tmin;
                var tv = tmin + pc * dt;
                return tv;
            }

            var fieldDistance, energyBar, replayMessage, fieldLevel, levelCircle;

            function init(event) {
                // UI

                fieldDistance = document.getElementById("distValue");
                energyBar = document.getElementById("energyBar");
                replayMessage = document.getElementById("replayMessage");
                fieldLevel = document.getElementById("levelValue");
                levelCircle = document.getElementById("levelCircleStroke");

                resetGame();
                createScene();

                createLights();
                createPlane();
                createSea();
                createCoins();
                createEnnemies();
                createParticles();

                document.addEventListener("mousemove", handleMouseMove, false);
                document.addEventListener("touchmove", handleTouchMove, false);
                document.addEventListener("mouseup", handleMouseUp, false);
                document.addEventListener("touchend", handleTouchEnd, false);

                loop();
            }

            window.addEventListener("load", init, false);
        </script>
    </body>
</html>
